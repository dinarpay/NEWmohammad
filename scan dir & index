#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <pthread.h>
#include <curl/curl.h>

#define MAX_LINES 10000
#define LINE_LENGTH 256
#define URL_LENGTH (2 * LINE_LENGTH + 10)
#define TIMEOUT 3L
#define MAX_THREADS 2500
#define PATHS_PER_BATCH 10

typedef struct {
    char target[LINE_LENGTH];
    char path[LINE_LENGTH];
    int progress;
    int total;
} CrawlArgs;

size_t write_callback(void *contents, size_t size, size_t nmemb, void *userp) {
    if (strstr((char *)contents, "Index of /") != NULL || strstr((char *)contents, "Directory listing for /") != NULL) {
        strcat(userp, "found");
    }
    return size * nmemb;
}

void *crawl_target(void *args) {
    CrawlArgs *crawl_args = (CrawlArgs *)args;

    char url[URL_LENGTH];
    snprintf(url, sizeof(url), "%s/%s/", crawl_args->target, crawl_args->path);

    char result[10] = "";
    CURL *curl = curl_easy_init();
    if (curl) {
        curl_easy_setopt(curl, CURLOPT_URL, url);
        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_callback);
        curl_easy_setopt(curl, CURLOPT_WRITEDATA, result);
        curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, 0L);
        curl_easy_setopt(curl, CURLOPT_TIMEOUT, TIMEOUT);

        curl_easy_perform(curl);
        curl_easy_cleanup(curl);

        if (strstr(result, "found") != NULL) {
            printf("Target URL: %s\n", url);
            FILE *results_file = fopen("results.txt", "a");
            fprintf(results_file, "%s\n", url);
            fclose(results_file);
        }
    }

    printf("Progress: %d/%d\n", crawl_args->progress, crawl_args->total);
    free(args);
    return NULL;
}

int main() {
    char targets[MAX_LINES][LINE_LENGTH];
    char paths[MAX_LINES][LINE_LENGTH];
    int total_targets = 0, total_paths = 0;

    FILE *targets_file = fopen("targets.txt", "r");
    FILE *paths_file = fopen("paths.txt", "r");

    if (targets_file == NULL) {
        fprintf(stderr, "Error opening targets.txt\n");
        return 1;
    }

    if (paths_file == NULL) {
        fprintf(stderr, "Error opening paths.txt\n");
        return 1;
    }

    while (total_targets < MAX_LINES && fgets(targets[total_targets], sizeof(targets[0]), targets_file)) {
        strtok(targets[total_targets], "\n");
        total_targets++;
    }

    while (total_paths < MAX_LINES && fgets(paths[total_paths], sizeof(paths[0]), paths_file)) {
        strtok(paths[total_paths], "\n");
        total_paths++;
    }

    fclose(targets_file);
    fclose(paths_file);

    pthread_t threads[MAX_THREADS];
    int thread_count = 0;

    for (int t = 0; t < total_targets; t++) {
        for (int p = 0; p < total_paths; p += PATHS_PER_BATCH) {
            for (int batch = 0; batch < PATHS_PER_BATCH && p + batch < total_paths; batch++) {
                if (thread_count == MAX_THREADS) {
                    for (int i = 0; i < MAX_THREADS; i++) {
                        pthread_join(threads[i], NULL);
                    }
                    thread_count = 0;
                }

                CrawlArgs *args = malloc(sizeof(CrawlArgs));
                strcpy(args->target, targets[t]);
                strcpy(args->path, paths[p + batch]);
                args->progress = t * total_paths + p + batch + 1;
                args->total = total_targets * total_paths;

                pthread_create(&threads[thread_count], NULL, crawl_target, args);
                thread_count++;
            }
        }
    }

    for (int i = 0; i < thread_count; i++) {
        pthread_join(threads[i], NULL);
    }

    return 0;
}
