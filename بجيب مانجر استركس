#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <pthread.h>
#include <curl/curl.h>

#define MAX_LINES 10000
#define LINE_LENGTH 256
#define URL_LENGTH (2 * LINE_LENGTH + 10)
#define TIMEOUT 5L
#define MAX_THREADS 250

typedef struct {
    char target[LINE_LENGTH];
    int progress;
    int total;
} CrawlArgs;

size_t write_callback(void *contents, size_t size, size_t nmemb, void *userp) {
    if (strstr((char *)contents, "Asterisk Call Manager") != NULL) {
        strcat(userp, "found");
    }
    return size * nmemb;
}

void *crawl_target(void *args) {
    CrawlArgs *crawl_args = (CrawlArgs *)args;

    char url[URL_LENGTH];
    snprintf(url, sizeof(url), "%s/", crawl_args->target);

    char result[10] = "";
    CURL *curl = curl_easy_init();
    if (curl) {
        curl_easy_setopt(curl, CURLOPT_URL, url);
        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_callback);
        curl_easy_setopt(curl, CURLOPT_WRITEDATA, result);
        curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, 0L);
        curl_easy_setopt(curl, CURLOPT_TIMEOUT, TIMEOUT);

        curl_easy_perform(curl);
        curl_easy_cleanup(curl);

        if (strstr(result, "found") != NULL) {
            printf("Target URL: %s\n", url);
            FILE *results_file = fopen("indexOF.txt", "a");
            if (results_file) {
                fprintf(results_file, "%s\n", url);
                fclose(results_file);
            } else {
                printf("Error opening indexOF.txt for writing.\n");
            }
        }
    }

    printf("Progress: %d/%d\n", crawl_args->progress, crawl_args->total);
    free(args);
    return NULL;
}

int main() {
    char targets[MAX_LINES][LINE_LENGTH];
    int total_targets = 0;

    FILE *targets_file = fopen("targets.txt", "r");

    if (targets_file == NULL) {
        fprintf(stderr, "Error opening targets.txt\n");
        return 1;
    }

    while (total_targets < MAX_LINES && fgets(targets[total_targets], sizeof(targets[0]), targets_file)) {
        strtok(targets[total_targets], "\n");
        total_targets++;
    }

    fclose(targets_file);

    curl_global_init(CURL_GLOBAL_DEFAULT);

    int processed_targets = 0;
    int current_target_index = 0;
    pthread_t threads[MAX_THREADS];

    while (processed_targets < total_targets) {
        int thread_count = 0;

        for (int t = current_target_index; t < total_targets && thread_count < MAX_THREADS; t++) {
            CrawlArgs *args = malloc(sizeof(CrawlArgs));
            strcpy(args->target, targets[t]);
            args->progress = processed_targets + 1;
            args->total = total_targets;

            pthread_create(&threads[thread_count], NULL, crawl_target, args);
            thread_count++;
            current_target_index++;
            processed_targets++;
        }

        for (int i = 0; i < thread_count; i++) {
            pthread_join(threads[i], NULL);
        }
    }

    curl_global_cleanup();

    return 0;
}
